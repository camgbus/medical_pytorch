# ------------------------------------------------------------------------------
# This class builds a descendant of torch.utils.data.Dataset from a
# mp.data.datasets.dataset.Dataset and a list of instance indexes.
# ------------------------------------------------------------------------------

import os
import torch
import random
from mp.paths import storage_data_path
from torch.utils.data import Dataset

class PytorchDataset(Dataset):
    def __init__(self, dataset, ix_lst=None, size=None):
        r"""A dataset which is compatible with PyTorch.

        Args:
            dataset (mp.data.datasets.dataset.Dataset): a descendant of the
                class defined internally for datasets.
            ix_lst (list[int]): list specifying the instances of 'dataset' to
                include. If 'None', all which are not in the hold-out dataset
                are incuded.
            size (tuple[int]): desired input size.

        :param resize: resize images into this new size.
        :param transform_lst: a list of torchvision transforms operations.
        :param norm: values to normalize the dataset with the form
        {'mean': tuple, 'std': tuple}, which can be generated by
        mp.utils.pytorch.compute_normalization_values
        """
        # Indexes
        if ix_lst is None:
            ix_lst = [ix for ix in range(len(dataset.instances))
                if ix not in dataset.hold_out_ixs]
        self.instances = [ex for ix, ex in enumerate(dataset.instances)
            if ix in ix_lst]
        self.size = size
        self.ds_name = dataset.name
        self.nr_labels = dataset.nr_labels
        self.restore_items = False

    def __len__(self):
        return len(self.instances)

    def set_item_saving(self, save_restore_k, subset_name='Run_0_train'):
        self.restore_items = False
        if save_restore_k is not None:
            self.k = save_restore_k
            self.save_path = os.path.join(storage_data_path, 'static_data',
            self.__class__.__name__, self.ds_name, subset_name)
            if not os.path.isdir(self.save_path):
                os.makedirs(self.save_path)
                self._save_items()
            self.restore_items = True  # __getitem__ checks whether this is set to decide whether to load or produce items.

    def _save_items(self):
        for kix in range(self.k):
            print(kix)
            for idx in range(self.__len__()):
                inputs, outputs = self.__getitem__(idx)
                inputs_name = 'X_'+str(idx)+'_'+str(kix)+'.pt'
                outputs_name = 'Y_'+str(idx)+'_'+str(kix)+'.pt'
                torch.save(inputs, os.path.join(self.save_path, inputs_name))
                torch.save(outputs, os.path.join(self.save_path, outputs_name))

    def _get_saved_item(self, idx):
        # Select ix in [0, k-1]
        kix = random.randint(0, self.k-1)
        # Load data
        inputs_name = 'X_'+str(idx)+'_'+str(kix)+'.pt'
        outputs_name = 'Y_'+str(idx)+'_'+str(kix)+'.pt'
        inputs = torch.load(os.path.join(self.save_path, inputs_name))
        outputs = torch.load(os.path.join(self.save_path, outputs_name))
        return inputs, outputs
